Mongoose for MongoDB :=
>> npm i mongoose
Mongoose is an Object Data Modeling (ODM) library for MongoDB, a NoSQL database. It provides a higher-level abstraction for working with MongoDB, making it easier for developers to interact with the database using JavaScript. Mongoose simplifies data modeling, schema creation, and validation, allowing developers to work with MongoDB in a more structured and intuitive way.
Here's a more detailed breakdown:
ODM (Object Data Modeling):
Mongoose allows developers to model data using JavaScript objects, which are then mapped to MongoDB documents. 
Schema-based:
Mongoose uses schemas to define the structure of documents in MongoDB collections, ensuring data integrity and consistency. 
Simplifies database interaction:
Mongoose provides a more developer-friendly way to interact with MongoDB compared to using the native MongoDB driver, which requires more manual query building and schema management. 
Benefits of using Mongoose: 
Easier data modeling: Mongoose makes it easier to create and manage data structures, especially for complex applications. 
Built-in features: Mongoose includes features like type casting, validation, and query building, reducing the need for manual coding. 
Improved code organization: Using Mongoose can lead to cleaner and more organized code, as it handles many of the low-level database operations.

Without Mongoose package, we have to use mongodb package(npm i mongodb) to insert data in DB, but mongodb package doesn't provide schemas or validations at the application level. 
Mongoose provide more facilities and security then mongodb. 
If you don't want to create schema and just want to insert data for small project, use mongodb. But if you want more restriction and validations, use mongoose.
mongodb : 
No schemas or validations at the application level.
No middleware/hooks (like pre-save, post-remove).
You must manually handle: Validation, Relationships, Data transformations, Timestamps, defaults, etc.
mongoose : 
Built on top of the mongodb driver.
Adds schema definitions, model-based data access, and validation.
Offers middlewares, virtuals, population (joins), plugins, etc.

Guide on how to use Mongoose to connect to MongoDB, define a schema, and perform basic queries :
‚úÖ 1. Install Mongoose
npm install mongoose

‚úÖ 2. Connect to MongoDB

const mongoose = require('mongoose');

const url = 'mongodb+srv://jubernowawave:JUBERkhan%40123@cluster0.n4tvq.mongodb.net/Eportal'; // connection url from mongodb atlas

mongoose.connect(url, {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('MongoDB connected'))
.catch(err => console.error('MongoDB connection error:', err));

‚úÖ 3. Define a Schema & Model
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  first_name: { type: String, required: true },
  last_name : String,
  age: Number,                           // Number
  isActive: Boolean,                     // Boolean
  birthday: Date,                        // Date
  profilePic: Buffer,                    // Binary Buffer. Used for storing binary data like files, images, or encrypted content.
  sport: {                             // ObjectId reference
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Sports' // ObjectId from Sports collection/table
  },
  tags: [String],                        // Array of Strings
  preferences: mongoose.Schema.Types.Mixed, // Mixed. A flexible type that can hold any kind of value ‚Äî object, array, string, etc.
  meta: {                                // Map of dynamic keys
    type: Map,
    of: String
  },
  price: mongoose.Schema.Types.Decimal128, //  Used for storing high-precision decimal numbers (like currency). eg: 999.99
}, {
  timestamps: true // adds createdAt and updatedAt
});

const User = mongoose.model('User', userSchema);
module.exports = User;

‚úÖ 4. Use the Model to Perform Queries
const User = require('./models/User');

// Create a new user
const newUser = await User.create({ name: 'Alice', age: 25, email: 'alice@example.com' });

// Find one user
const foundUser = await User.findOne({ name: 'Alice' });

// Update a user
await User.updateOne({ name: 'Alice' }, { age: 26 });

// Delete a user
await User.deleteOne({ name: 'Alice' });

// Find all users
const allUsers = await User.find();

üí° Pro Tips:
You can use Mongoose middleware (e.g. pre('save')) for logic before/after database actions.

Add custom methods or virtual fields on schemas.

Use .lean() for faster queries if you don‚Äôt need Mongoose documents.


üõ† Notes:
Mixed: Useful for flexible or dynamic structures, but disables strict schema enforcement.
Map: Good for storing arbitrary key-value pairs (e.g., localized content).
Decimal128: Use when you need accurate decimal math (e.g., currency).
UUID: Not natively supported in schema types ‚Äî use as a String or with a plugin.

Buffer : 
Used for storing binary data like files, images, or encrypted content.
 
const mongoose = require('mongoose');

const fileSchema = new mongoose.Schema({
  fileName: String,
  data: Buffer,
  contentType: String
});

const File = mongoose.model('File', fileSchema);


const fs = require('fs');

const image = fs.readFileSync('path/to/image.jpg');
await File.create({
  fileName: 'image.jpg',
  data: image,
  contentType: 'image/jpeg'
});


üîπ 3. Decimal128
‚û§ Used for storing high-precision decimal numbers (like currency). Avoids floating point errors found in Number.

const productSchema = new mongoose.Schema({
  name: String,
  price: mongoose.Schema.Types.Decimal128
});

const Product = mongoose.model('Product', productSchema);

await Product.create({
  name: 'Laptop',
  price: mongoose.Types.Decimal128.fromString('999.99')
});

const item = await Product.findOne();
console.log(item.price.toString()); // '999.99'

üîπ 4. Map
‚û§ Used to store dynamic key-value pairs. All values in a map must be of the same type.
const userSchema = new mongoose.Schema({
  name: String,
  settings: {
    type: Map,
    of: String
  }
});

const User = mongoose.model('User', userSchema);
await User.create({
  name: 'Alice',
  settings: {
    theme: 'dark',
    language: 'en',
    timezone: 'IST'
  }
});
const user = await User.findOne({ name: 'Alice' });
console.log(user.settings.get('theme')); // 'dark'

why use map method .get() : 
console.log(user.settings.theme);      // ‚ùå Might be undefined
console.log(user.settings['theme']);  // ‚ùå Unreliable

These methods may not work reliably because Mongoose's Map is not a plain JavaScript object ‚Äî it's an instance of Map under the hood and behaves differently from plain objects.
They may appear to work in some cases (e.g., after converting the document to a plain object), but they‚Äôre not safe.
Convert to a plain object (if needed) :
If you really want to use object-style access, convert the map to a plain object.
const settingsObj = Object.fromEntries(user.settings);
console.log(settingsObj.theme); // ‚úÖ Safe after conversion
or
console.log(user.settings.toObject().theme);



why map is better than normal object : https://github.com/69JINX/FrontEnd/blob/main/Notes/Notes_Pic/map-is-better-than-object.png

