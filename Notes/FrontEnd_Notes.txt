Scope
1. Block scope - variables declared inside a pair of curly braces cannot be accessed from outside
the block
2. Function scope - variables declared inside a function cannot not be accessed from outside the
function
3. Global scope - globally scoped variables can be accessed inside a block or function

eg. Block Scope :
{
  const x = 123;
  console.log(x); // 123
}
console.log(x) // Error : 'x' is not defined


Closure
In JavaScript, when we return a function from another function, we are effectively returning a combination of the function definition along with the function's scope. This would let the function definition have an associated persistent memory which could hold on to live data between executions. That combination of the function and its scope chain is what is called a closure in JavaScript.

scenario 1 :
const outer = ()=>{
    let counter = 0;
    const inner =()=>{
        counter++;
        console.log(counter);
    }
    inner();
}

outer();// counter set to 0
outer();// counter set to 0 again and increased by 1 by inner() function, because it was only called one time in the outer function.

Output : 
1
1

scenario 2 (Closure) :
// Define a function `outer` which declares a local variable `counter`
const outer = () => {
    let counter = 0; // `counter` is scoped to the `outer` function

    // Define an inner function that increments and logs `counter`
    const inner = () => {
        counter++;               // Increase the value of counter
        console.log(counter);    // Print the updated value
    }

    // Return the `inner` function from `outer`
    return inner; // This forms a closure: `inner` "remembers" `counter`
}

// Call `outer` and store its return value (which is the `inner` function) in `fun1`
const fun1 = outer(); // Here, `counter` is initialized to 0 and `fun1` holds reference to `inner`

fun1(); // Logs: 1
// - `counter` is incremented from 0 to 1
// - Because `inner` still "remembers" its outer `counter`, the state persists

fun1(); // Logs: 2
// - `counter` is now incremented again (1 → 2)
// - The same closure is being used, so the same `counter` variable is being updated

// Note:
// Even though `outer` has finished execution, `counter` isn't garbage collected
// because the returned `inner` function (stored in `fun1`) still has access to it.
// This behavior is called a "closure" — where a function remembers its lexical scope.

// both fun1 are still running inside the outer function and counter never convereted to 0 again, which caused the counter to increased two times

Output : 
1
2


Function Currying
Currying is a process in functional programming in which we transform a function with multiple
arguments into a sequence of nesting functions that take one argument at a time.
Currying in JavaScript transforms a function with multiple arguments into a sequence of functions, each taking a single argument. This technique offers several benefits:
1. Code Reusability: Curried functions can be reused in various contexts. By partially applying arguments, new functions can be derived from existing ones, reducing code duplication.
2. Improved Readability: Breaking down complex logic into smaller, manageable pieces makes the code easier to understand and maintain.
3. Enhanced Flexibility: Currying enables more flexible function composition. Functions can be combined and reused in different ways, adapting to changing requirements. 
4. Partial Application: Currying facilitates partial application, allowing you to create specialized functions by fixing some arguments of a more general function.
5. Functional Programming: Currying promotes functional programming practices, leading to more robust and maintainable code.
6. Simplified Function Calls: By pre-filling some arguments, function calls can be simplified, making code more concise.
7. Avoid Repetition: Currying helps avoid repeating the same arguments multiple times, making code more streamlined.
8. Higher-Order Functions: Currying enables the creation of higher-order functions, enhancing the flexibility and power of your code.
function f(a,b,c) is transformed to f(a)(b)(c)

1. Without Currying
function logMessage(prefix, message) {
  console.log(`[${prefix}] ${message}`);
}

// Usage
logMessage("INFO", "Server started");
logMessage("ERROR", "Something went wrong");
You have to repeat "INFO" or "ERROR" every time you call it — no reusability.

2. With Currying
function curriedLog(prefix) {
  return function(message) {
    console.log(`[${prefix}] ${message}`);
  }
}

// Usage
const infoLogger = curriedLog("INFO");
const errorLogger = curriedLog("ERROR");

infoLogger("Server started");        // [INFO] Server started
errorLogger("Something went wrong"); // [ERROR] Something went wrong

