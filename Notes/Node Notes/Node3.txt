👉🏻Express
Below are the Response methods that are provided by ExpressJS

1. res.send([body]) : Sends a generic response. It can send strings, objects, arrays, or buffers, and automatically sets the appropriate Content-Type header based on the data type and ends the response process.

Key functionalities of res.send():
i) Sends diverse data types:
It can send plain text, HTML, JSON objects, arrays, and Buffer objects as the response body.
ii) Automatic Content-Type handling:
res.send() intelligently determines and sets the Content-Type header based on the type of data being sent. For instance, if sending a JavaScript object, it will set Content-Type to application/json.
iii) Ends the response:
After sending the data, res.send() effectively terminates the response cycle, preventing further processing in the current request-response chain. ex : 
res.send('hello from 1st response');
res.send('hello from 2nd response'); 
The 2nd response will never reach to the client because of the 1st response that has already terminated the response process
iv) Optional status code:
You can chain res.status() before res.send() to explicitly set the HTTP status code for the response (e.g., res.status(404).send('Not Found')). If no status code is specified, it defaults to 200 (OK). ex: 
res.status(404).send('Sorry, the requested resource was not found.');

2. res.json([body]): Sends a JSON response. It is similar to res.send() but specifically formats the response as JSON.

3.sendFile :
Sends a file at the given path to the client. It automatically sets the Content-Type header based on the file's extension. 
res.sendFile(path [, options] [, callback]);
ex : 
app.get('/view-pdf',(req,res)=>{
  res.sendFile(process.cwd() + '/sample.pdf');
});

4. download :
Prompts the client to download a file. It sets the Content-Disposition header to trigger a download.
res.download(path [, filename] [, options] [, callback]);
ex : 
app.get('/download-pdf',(req,res)=>{
  res.download(process.cwd() + '/sample.pdf','Testing.pdf');
});

5. render : Renders a view template (e.g., Pug, EJS, Handlebars) with a set of locals (data) and sends the resulting HTML to the client.
res.render(view [, locals] [, callback])

6. redirect : Redirects the client to a new URL. The status code defaults to 302 (Found).
res.redirect([status,] path)

7. status : Sets the HTTP status code for the response. This method is often chained with other methods like send() or json().
res.status(code)
ex :
app.get('/test',(req,res)=>{
  res.status(401);
  res.send("Hello"); // this will still set 401 status on this send response
});

8. end :
Concludes the response process without sending any data. It is derived from Node.js's http.ServerResponse.end() method. It does not automatically set Content-Type headers or handle data formatting.
res.end([data] [, encoding])
ex :
res.end("Ended the process!"); // the text will be send but no information related to response will be send

9. cookie : In Express.js, res.cookie() is a method used to set a cookie in the client's browser as part of the HTTP response. This allows the server to store small pieces of data on the client-side, which can then be sent back to the server with subsequent requests.
res.cookie(name, value, [options])

app.get('/test',(req,res)=>{
  res.cookie('user_id', '12345', { maxAge: 3600000}); // Sets a cookie named 'user_id' with a value, expiring in 1 hour 
  res.send('Cookie set successfully!');
});

10. clearCookie : Clears a cookie with the specified name and optional options.
res.clearCookie(name [, options])

11. set/header : Sets an HTTP response header field.
res.set(field [, value]) / res.header(field [, value])
app.get('/example', (req, res) => {
   res.set('Content-Type', 'application/json');
   res.set('Cache-Control', 'no-cache');
   res.send({ message: 'Hello' });
});
You can also pass an object to set multiple headers at once:
res.set({
    'Content-Type': 'text/html',
    'X-Powered-By': 'Express'
});

Using Middleware for Global Headers:
To set headers for all or a group of routes, use middleware. Place the middleware before your route handlers.

app.use((req, res, next) => {
   res.set('X-Custom-Header', 'My App');
   next(); // Pass control to the next middleware or route handler
});

app.get('/', (req, res) => {
   res.send('Home page');
});

res.header is an alias for res.set();
deep dive into headers : https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers

12. res.headersSent : This boolean property indicates whether the HTTP headers for the response have already been sent to the client. Once true, you cannot set or modify headers.
ex :
app.get('/test',(req,res)=>{
   console.log(res.headersSent); // false
   res.set('Content-Type', 'application/json');
   console.log(res.headersSent); // false
   res.send({ message: 'Hello' });
   console.log(res.headersSent); // true
});

13. append : Appends the specified value to the HTTP response header field. If the header is not already set, it creates it. 
res.append(field, value)
difference :
> res.set() overwrites: existing header values.
> res.append() adds to: existing header values if they support multiple values, like 'Set-Cookie' or 'Vary' (or creates them if they don't exist).

13. locals : An object that holds response local variables specific to the current request. These variables can be accessed within view templates.
Unlike app.locals (which holds application-wide local variables), res.locals is unique to each incoming request. This means that data stored in res.locals for one request will not be accessible to other concurrent requests.
Variables defined on res.locals become directly accessible within your view templates (e.g., EJS, Pug, Handlebars) when you render them using res.render().

const middleware = (req,res,next)=>{
 res.locals.user = 'Avinash';
 next();
}

app.get('/',middleware,(req,res)=>{
  res.json(res.locals);
});

output :
{"user":"Avinash"}


👉🏻ExpressJs Middlewares
1. Application-Level Middleware
2. Router-Level Middleware
3. Route-Specific Middleware
4. Chaining Multiple Middleware Functions
5. Error-Handling Middleware
6. Third-party middleware

1. Application-Level Middleware:
> Applied globally to all incoming requests using app.use().
> Examples include logging, body parsing (e.g., express.json(), express.urlencoded()), and static file serving (express.static()).

const express = require('express');
const app = express();

// Global logging middleware
app.use((req, res, next) => {
  console.log(`Time: ${Date.now()}`);
  next();
});

// Body parsing middleware
app.use(express.json());

2. Router-Level Middleware:
> Applied to specific routes or a group of routes defined within an Express Router instance using router.use() or router.METHOD().
> Useful for organizing middleware related to specific feature areas or API endpoints.

const express = require('express');
const router = express.Router();
const { getUsers, createUser } = require('./controllers')

// Middleware specific to this router
router.use((req, res, next) => {
    console.log('Router-Level middleware executed');
    next();
});

router.get('/users', getUsers);
router.post('/user-create', createUser);

module.exports = router; // import and use app.use('/api', router)

3. Route-Specific Middleware:
> Applied directly to individual route handlers using app.METHOD().
> Allows for fine-grained control over which middleware runs for a particular route.

const express = require('express');
const router = express.Router();
const { getUsers, createUser } = require('./controllers')

// Middleware specific to this router
const middleware = (req, res, next) => {
    console.log('Router-Specific middleware executed');
    next();
};

router.get('/users', middleware, getUsers);
router.post('/user-create', createUser);

module.exports = router;

4. Chaining Multiple Middleware Functions:
> Multiple middleware functions can be chained together for a single route or app.use() call.
> They execute in the order they are defined, with each calling next() to pass control to the subsequent function.

const express = require('express');
const app = express();

const middleware1 = (req, res, next) => { console.log('Middleware 1'); next(); };
const middleware2 = (req, res, next) => { console.log('Middleware 2'); next(); };

app.get('/chained', middleware1, middleware2, (req, res) => {
    res.send('Chained middleware executed');
});

5. Error-Handling Middleware:
> Defined with four arguments (err, req, res, next) and placed at the end of the middleware stack.
> Catches and handles errors that occur during the any above route, request-response cycle.

const express = require('express');
const app = express();

// ... other middleware and routes ...

// Error-handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Something broke!');
});

6. Third-party middleware
Use third-party middleware to add functionality to Express apps.
Install the Node.js module for the required functionality, then load it in your app at the application level or at the router level.
The following example illustrates installing and loading the cookie-parsing middleware function cookie-parser.
>> npm install cookie-parser

const express = require('express')
const app = express()
const cookieParser = require('cookie-parser')

// load the cookie-parsing middleware
app.use(cookieParser())


👉🏻Request Handling 
Accessing data sent from the frontend in a Node.js backend typically involves handling HTTP requests. The primary methods for this are:
1. Request Body
2. URL/Route Parameters 
3. Query Parameters 
4. Request Headers

1. Request Body :
Definition: Request body parameters are included in the body of the request (e.g., in a POST or PUT request). They are typically used to send data to the server for creating or updating resources.
Access: To access request body parameters, you need to use middleware like body-parser or express.json() to parse the request body.
Example: 
const express = require('express');
const app = express();
const bodyParser = require('body-parser');

app.use(bodyParser.json()); // or app.use(express.json());

app.post('/users', (req, res) => {
  const username = req.body.username;
  const email = req.body.email;
  // ... use username and email to create a new user
});

Body Parsing Middleware :
The req.body object is not directly accessible in Express.js without parsing middleware because, by default, Express does not automatically parse the incoming request body. When an HTTP request with a body (like a POST or PUT request) arrives at an Express server, the body is received as a raw stream of data bytes. Express, on its own, does not have built-in mechanisms to interpret and structure this raw data into a convenient JavaScript object.

Parsing middleware, such as express.json() or express.urlencoded() (or the older body-parser library), is designed to:
> Read the raw stream: It intercepts the incoming request and reads the raw data from the request body.
> Parse the data: It then interprets this raw data based on the Content-Type header of the request (e.g., as JSON, URL-encoded form data, or plain text).
> Populate req.body: Finally, it parses the data into a usable JavaScript object or string and attaches it to the req.body property of the request object, making it easily accessible in subsequent route handlers.

Middleware like express.json() (for JSON payloads) or express.urlencoded() (for URL-encoded form data) are designed to intercept these incoming request streams. They read the raw data, parse it according to the specified content type (e.g., application/json, application/x-www-form-urlencoded), and then attach the parsed data to the req.body property of the request object.

Specific Content Types:
Different types of request bodies require different parsing methods. For example, express.json() handles JSON payloads, while express.urlencoded() handles URL-encoded data from HTML forms. For multipart/form-data (often used for file uploads), specialized middleware like Multer is required, as express.json() and express.urlencoded() are not designed to handle this content type.

Without this middleware, you would need to manually handle the incoming data stream, which involves listening for data chunks, concatenating them, and then parsing the resulting buffer, a process that is significantly more complex and error-prone. The middleware abstracts this complexity, allowing developers to focus on application logic.

2. URL/Route Parameters : 
Definition: Route parameters are placeholders in the URL path that capture dynamic values. They are defined using a colon (:) followed by a parameter name (e.g., /users/:id (/users/2), /products/:category/:productId (/products/chips/32)).
Access: Route parameters are accessed through the req.params object within the route handler (e.g., req.params.id, req.params.productId).
Example: 
app.get('/users/:id', (req, res) => {
  const userId = req.params.id;   // ... use userId to fetch user data
  console.log(req.params);
});

output :
{ id: '2' }

3. Query Parameters:
Definition: Query parameters are key-value pairs appended to the URL after a question mark (?). They are used to filter, sort, or paginate data (e.g. /products?sort=price&order=desc).
Access: Query parameters are accessed through the req.query object within the route handler (e.g., req.query.sort, req.query.order).
Example:
app.get('/products', (req, res) => {
  const sortBy = req.query.sort;  // ... use sortBy and order to fetch products
  const order = req.query.order;
  console.log(req.query);
});

output :
{ sortBy: 'price', order: 'desc' }

4. Request Headers :
Used for metadata sent with the request, such as Authorization tokens, Content-Type, or User-Agent to be sent in the HTTP headers.
app.get('/api/secure-data', (req, res) => {
  const authToken = req.headers.authorization; // Access the Authorization header
  console.log('Authentication token:', authToken);
  res.status(200).json({ message: 'Secure data accessed' });
});

sending headers from frontend (axios):
await axios.post('/api/secure-data', { name: 'John Doe' }, {
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`
  }
})

👉🏻Route Chaining :
Router chaining refers to the practice of applying multiple middleware functions or route handlers to a single route path, or chaining different HTTP methods (GET, POST, PUT, DELETE, etc.) to the same route path. This approach enhances code organization, readability, and modularity.
ex :
const express = require('express');
const app = express();

const viewData = (req,res) => res.send('Data Viewed');
const updateData = (req,res) => res.send('Data Updated');
const deleteData = (req,res) => res.send('Data Deleted');

app
.get('/data',viewData)
.post('/data',updateData)
.delete('/data',deleteData);

app.listen(4000,()=>{
 console.log('server is running at port 4000');
})

router.route() :
to prevent writing the same route in every single http request, the route() method can be used to define a single route for all the requests.
This method returns an instance of a single route, allowing you to chain different HTTP method handlers to that specific route.

app.route('/data')
.get(viewData)
.post(updateData)
.delete(deleteData);

👉🏻Nested Routing
Nested routing in Express.js refers to the practice of organizing routes hierarchically by attaching one Express Router instance as middleware to another. This approach allows for a modular and structured way to manage complex application routes, enhancing code organization and maintainability.
How it works:
Create separate routers:
Define specific sets of related routes within their own express.Router() instances. For example, you might have a userRouter for all user-related routes (/users, /users/:id) and a postRouter for post-related routes (/posts, /posts/:id).

Attach child routers to parent routers (or the main app):
Use app.use() or router.use() to mount a child router at a specific path prefix on a parent router or the main Express application instance.
const express = require('express');
const app = express();
const userRouter = require('./routes/users'); // Assuming users.js exports a router
const postRouter = require('./routes/posts'); // Assuming posts.js exports a router

app.use('/users', userRouter); // All routes in userRouter will be prefixed with /users
app.use('/posts', postRouter); // All routes in postRouter will be prefixed with /posts

👉🏻Wildcard routing
Wildcard routing in Express.js allows for handling routes that match a broad range of URL patterns, particularly when the exact route is not known in advance or to serve as a catch-all for undefined routes.
Using the Wildcard Character (*)
The asterisk (*) is used as a pattern to match all remaining routes. This is commonly employed to create a "404 Not Found" page or to handle unexpected URLs.
app.get('*', (req, res) => {
  res.status(404).send('Page not found!');
});

Important Considerations:
Order of Routes:
The wildcard route should be placed after all other specific routes in your Express application. Express processes routes in the order they are defined. If the wildcard route is placed earlier, it will catch all requests before more specific routes can be matched, leading to unintended behavior.
Matching Specific Subsets:
Wildcards can also be used to match specific subsets of URLs, such as /posts/* to match all paths within the /posts/ directory.
Accessing Matched Parameters:
When using a wildcard like /root/*, the matched part of the URL (e.g., foo/bar from /root/foo/bar) can be accessed via req.params[0].

👉🏻API Security
Securing a Node.js API involves implementing various measures to protect against common vulnerabilities and threats. Key aspects of Node.js API security include:
1. Form Validation (express-validator)
2. CSRF Token (scurf)
3. Password Hashing (Bcrypt)
4. JWT Authentication (jsonwebtoken)
5. Rate limiting (npm i express-rate-limit)
6. Helmet (HTTP Security Headers)
7. CORS Policy
8. XSS Protection
9. Prevent Parameter Pollution
10. SQL/NoSQL Injection Defense
11. File Upload Security (using Multer)
12. HTTPS Enforcement
13. Passport.js (node library for local strategy, OAuth etc.) // docs: https://www.passportjs.org/
14. Role-Based Access Control (RBAC)
15. Dependency Security (scan and detect security vulnerabilities in Node. js modules ex: npm audit)
16. Disable Express Fingerprinting (app.disable('x-powered-by');)
17. Payload Size Limit (app.use(express.json({ limit: '1mb' }));)
18. Logging & Monitoring

If you follow these points, your API will cover most OWASP Top 10 risks for backend apps.

OWASP(Open Web Application Security Project) : https://www.cloudflare.com/en-gb/learning/security/threats/owasp-top-10/

Details and example code about each point : https://github.com/69JINX/FrontEnd/blob/main/Notes/Notes_Pic/Api_Securities.png

single security.js middleware file that you just app.use() in your Express app to enable most of these protections in one place :
security.js : https://github.com/69JINX/FrontEnd/blob/main/Notes/Node%20Notes/practice/api_security/security.js 


👉🏻Application Settings and Configuration
app.set()/app.get(key) :
The app.set() function in Express.js is used to assign a setting name to a value. While it can store any type of value, there are specific predefined settings that configure the behavior of the Express application. These settings are accessible using app.get().


app.set('port', 3000); 
const port = app.get('port'); // 3000

what about the app.get we use to define a route :
app.get('/', (req, res) => { 
  res.send("welcome to home page"); 
});

Even though both are app.get, their meanings differ depending on arguments:
> One argument → retrieve a setting.
> Two arguments (path, handler) → register a route.


Quick Summary
> app.set(key, value) → configure application settings.
> app.get(key) → fetch a setting.
> app.get(path, handler) → define a route handler.

to retrieve a setting inside any controller :
const port = req.app.get('port')

to retrive a setting in other modules, export the 'app' from server.js and import the app in any other module to retrieve a setting

Common Predefined Settings:
env: Represents the application's environment (e.g., 'development', 'production'). It defaults to process.env.NODE_ENV.
etag: Controls ETag generation for responses. Can be 'weak', 'strong', false, or a function.
etag fn: You can pass your own function for generating ETags.
jsonp callback name: Specifies the default JSONP callback name.
json escape: Enables JSON escaping for responses.
json replacer: A replacer function for JSON.stringify() in JSON responses.
json spaces: The number of spaces to use for pretty-printing JSON responses.
case sensitive routing: Enables case-sensitive routing.
strict routing: Enables strict routing (trailing slashes matter).
trust proxy: Indicates if the application is behind a front-facing proxy and should use X-Forwarded-* headers. 
views: The directory or array of directories for the application's views (templates). 
view cache: Enables view template compilation caching.
view engine: The default engine extension to use when omitting the extension in res.render().
x-powered-by: Controls the X-Powered-By: Express HTTP header.
subdomain offset: Controls which part of hostname is the subdomain.

Custom Settings:
Beyond the predefined settings, app.set() can be used to store any custom data or configuration that needs to be accessible throughout the application. For example:
app.set('title', 'My Awesome App');
app.set('port', 3000);
app.set('databaseUrl', 'mongodb://localhost/mydb');

Shorthand Methods:
app.enable(name): shorthand for boolean settings. Sets a boolean setting name to true. Equivalent to app.set(name, true).
app.disable(name): shorthand for boolean settings. Sets a boolean setting name to false. Equivalent to app.set(name, false).
app.enabled(name): check if enabled
app.disabled(name): check if disabled

X-Powered-By :
The X-Powered-By header is an optional and non-standard HTTP response header that indicates the technology stack or framework used by the web server to generate the HTTP response. It is often included by popular server software and scripting languages to identify the name and version number of the software used. 

Where you can see x-powered-by:
If you inspect your webpage and go into the network tab, you can see this property in the Headers tab of any api call under the Response Headers section. (If you still can't find it, go into network tab and press ctrl+f and type x-powered-by, you will see all the APIs that have x-powered-by propery in the Response headers.


Identification:
The primary purpose is to identify the underlying technologies, such as the specific version of PHP, ASP.NET, Node.js, or a particular web application framework.
Debugging and Development:
For developers, this header can be useful during debugging and development by providing quick insights into the server environment and configuration.
Security Implications:
While potentially useful for development, the X-Powered-By header can also pose a security risk by revealing sensitive information about the server's technology stack to potential attackers. This information can be used for:
Reconnaissance:
Attackers can use this header to identify the software and versions running on the server.
Targeted Attacks:
Knowing the technology stack allows attackers to research known vulnerabilities associated with that specific software and version, enabling them to launch more targeted and effective attacks.
Mitigation:
Due to the security implications, it is generally recommended to remove or modify the X-Powered-By header in production environments to avoid disclosing unnecessary information. This can typically be achieved by configuring the web server or application framework to either disable or customize this header.

Disable X-Powered-By :
In backend >
To disable this property from appearing under the Response headers of your api call in frontend so attackers can't identify your backend technology stack, you can disable it from backend using :
const express = require('express');
const app = express();
app.disable('x-powered-by')

In frontend >
To remove the X-Powered-By header in Next.js :
Inside next.config.js, add or modify the poweredByHeader property within the module.exports object and set its value to false.
// next.config.js
module.exports = {
 poweredByHeader: false,
};

👉🏻 Accessing cookies in backend

Cookies can be accessed in the backend in a controller by :
1. req.headers.cookie // token=eyJhbGciOiJI
2. req.cookies // if you are using cookie-parser middleware. app.use(cookieParser()); { token : "eyJhbGciOiJI" }

The benefit of cookie-parser middleware is that is provides cookies name and their values in an object as key-value pairs instead of as a string.
Allow backend to accept cookies :
app.use(cors({
  origin: 'http://localhost:3000', // your frontend port
  credentials: true
}));

Note : origin have to be specific when allowing credentials true
origin: '*' + credentials: true doesn’t work
By design, the CORS spec does not allow Access-Control-Allow-Origin: * if you also send Access-Control-Allow-Credentials: true.
Why?
Because cookies, HTTP auth, and TLS client certs are sensitive. If browsers allowed "*" with credentials, then any site on the internet could make authenticated requests on behalf of your users — a huge security hole.
So browsers enforce this rule:
If credentials: true → Access-Control-Allow-Origin must be a specific origin, not *.

sending cookies from frontend :
1. fetch :
const response = await fetch('http://localhost:8000/api/receive-cookie', {
        method: 'POST', // or 'POST', 'PUT', etc.
        credentials: 'include', // This is crucial for sending cookies
})

2. axios :
const response = await axios.post('http://localhost:8000/api/receive-cookie', {}, { withCredentials: true }) 
// withCredentials to allow sending cookies

👉🏻 Compression middleware
Compression middleware in Node.js, often implemented using packages like compression for Express.js, serves to compress outgoing HTTP responses before they are sent to the client. This process reduces the size of the data payload, leading to several benefits for your backend and the overall application performance.

Use of Compression Middleware:
Reduces Data Transfer Size:
It applies compression algorithms, such as Gzip or Brotli, to the response body, significantly shrinking the amount of data that needs to be sent over the network.
Improved Load Times:
Smaller data payloads translate directly to faster download times for clients, especially beneficial for users on slower networks or mobile devices.
Reduced Bandwidth Usage:
By minimizing the data transferred, it conserves bandwidth for both your server and the client, potentially lowering hosting costs and improving user experience.
Better Performance on Slow Networks:
Users with limited bandwidth or high latency connections experience a more responsive application due to the reduced data transfer.
Automatic Content Negotiation:
Compression middleware can automatically detect if the client supports compression (via the Accept-Encoding header) and only compress responses when supported.

Benefits for Your Backend:
Reduced Server Load:
While compression itself consumes some CPU cycles, the reduction in network I/O often outweighs this, leading to a net decrease in server load, especially under high traffic.
Optimized Resource Utilization:
By reducing bandwidth consumption, your backend can serve more requests with the same network resources, improving scalability.
Enhanced User Experience:
Faster load times and improved responsiveness directly contribute to a better user experience, which can lead to increased engagement and satisfaction.
In essence, compression middleware is a low-effort, high-impact optimization that can significantly enhance the performance and efficiency of your Node.js backend.

const compression = require('compression');
app.use(compression());

Without using compression middleware :
insert img > FrontEnd/Notes/Notes_Pic/without_compression.png

When using compression middleware :
insert img > FrontEnd/Notes/Notes_Pic/with_compression.png

Note : 
If the response size is already too small, compression will actually add more size to it. This is due to extra header that compression adds. It needs extra header to let browser know that this data was compressed and browser needs to decompress it. If you look into response headers, for compression enabled this is extra header => 
> Content-Encoding: gzip (or deflate/br depending on algorithm) → tells browser how to decode it.
> Vary: Accept-Encoding → tells caches that the response may differ depending on the client’s supported encoding.
Due to the fact that data is already small, compression library decided not to use any compression algorithm, or algorithm itself decided not to change anything, since in some cases extra compression overhead is not worth it.

By default, Express’s compression middleware skips responses under 1KB.
If you force compression using the below command, then small responses may end up slightly larger due to the added Content-Encoding header and compression framing.
app.use(compression({ threshold: 0 })); // compress everything, even small responses

if you force compression on very small responses (by setting threshold: 0), response size will increase:
> Original: 150 bytes
> Compressed: ~200 bytes (due to compression headers + gzip framing overhead).
That’s why the default threshold is 1KB.
it’s not only about the Vary header, but mainly because of the gzip framing overhead + headers. The library is smart enough to skip compressing tiny payloads.

👉🏻 ORM vs ODM

ORM and ODM are both techniques used in software development to interact with databases using object-oriented programming concepts, abstracting away the complexities of raw database queries. The key difference lies in the type of database they are designed to work with:

ORM (Object-Relational Mapping):
Purpose: ORMs are used with relational databases like PostgreSQL, MySQL, SQL Server, etc. They map objects in your code to tables and rows in a relational database.
Data Model: They operate on a structured, predefined schema where data is organized into tables with fixed columns and relationships.
Examples: Hibernate (Java), Entity Framework (.NET), SQLAlchemy (Python), Sequelize (Node.js -> npm i sequelize).

ODM (Object-Document Mapping):
Purpose: ODMs are used with document-based NoSQL databases like MongoDB, Couchbase, etc. They map objects in your code to documents in a document database collection.
Data Model: They are designed for flexible, semi-structured data where documents can have varying fields and nested structures. While they can support schema definitions for validation, they are more adaptable to evolving data models.
Examples: Mongoose (Node.js for MongoDB -> npm i mongoose), MongoEngine (Python for MongoDB). 

In essence:
Choose ORM
when working with relational databases and require strong schema enforcement, complex joins, and transactions.
Choose ODM
when working with document databases and need flexibility in data structure, scalability, and ease of handling semi-structured data.

👉🏻 Backend Roadmap :
https://roadmap.sh/backend
