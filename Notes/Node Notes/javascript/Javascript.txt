👉🏻 How javascript works & Execution context
Everything in Javascript happens inside an Execution Context.

ref :
https://www.freecodecamp.org/news/how-javascript-works-behind-the-scene-javascript-execution-context/
https://www.youtube.com/watch?v=iLWTnMzWtj4&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP

In JavaScript, an execution context is an abstract concept that defines the environment in which JavaScript code is executed. It's essentially a container that holds all the necessary information for the current code to run, including variables, functions, and the scope chain. 
Every time JavaScript code is run, it runs within an execution context. There are two primary types of execution contexts:
1.) Global Execution Context (GEC):
This is the base execution context and is created when the JavaScript engine first starts up and loads a script.
It represents the global scope, meaning any variables or functions declared outside of any function are part of the GEC.
There is only one GEC for a given JavaScript program.
2.) Function Execution Context (FEC):
A new FEC is created every time a function is called.
Each FEC has its own scope, variables, and arguments specific to that function call.
When a function finishes executing, its FEC is typically popped off the call stack and destroyed.
Key Components of an Execution Context:

Each execution context is composed of two main phases:
1.) Memory Creation Phase:
Variable Environment (Memory Component): This is where variables and function declarations within that context are stored. During this phase, memory is allocated, and initial values (like undefined for variables) are assigned. This is also where hoisting happens.
Scope Chain: This defines the hierarchical order in which variables and functions are looked up. It determines which variables and functions are accessible from the current context.
this Binding: The this keyword is assigned a value based on how the function was called.
2.) Execution Phase (Thread of Execution):
During this phase, the JavaScript engine executes the code line by line within the established environment, assigning actual values to variables and running the function logic.

How it Works (Simplified):
When JavaScript encounters a function call, a new FEC is created and pushed onto the call stack (also known as the execution stack). The JavaScript engine then executes the code within that FEC. Once the function completes, its FEC is popped off the call stack, and control returns to the previous execution context. This process allows JavaScript to manage the flow of execution and maintain proper scope for variables and functions.

Program flow with an example :
var n = 2;
function square (num){
    var ans = num * num;
    return ans;
}

var square1 = square(n);
var square2 = square(4);

When you run a javascript program, a 'Global Execution Context' is created. 
The execution context for will go through 2 main faces (creation & execution phase) for every single FEC present in the program.
Insert Image >> /FrontEnd/Notes/Notes_Pic/JS_EC_0.png

1. Memory Creation phase: in this phase, js will allocate memory to all the variables and function present in the program, stores the variables (defined with var) with values as undefined and function references. So in the above program, variables & functions will be stores in the memory like :
Insert Image >> /FrontEnd/Notes/Notes_Pic/JS_EC_1.png

After this Memory creation phase, the execution context will move to the code execution phase.

2. Execution Phase : Now, in this phase, it starts going through the entire code line by line from top to bottom. As soon as it encounters n = 5, it assigns the value 5 to 'n' in memory. Until now, the value of 'n' was undefined by default.
Then we get to the 'square' function. As the function has been allocated in memory, it directly jumps into the line var square1 = square(n);. square() will be invoked and JavaScript once again will create a new FEC (function execution context). Whenever a new function is encountered in the program, it will create a new FEC in the call stack. 
Nested Function Execution Contexts (FECs) are created during the execution phase of the parent execution context, specifically when a nested function is invoked.
Insert Image >> /FrontEnd/Notes/Notes_Pic/JS_EC_2.png
Once the calculation is done, it assigns the value of square in the 'ans' variable that was undefined before. The function will return the value, and the FEC (function execution context) will be destroyed.

The returned value from square() will be assigned on square1. This happens for square2 also. Once the entire code execution is done completely, the global context will look like this and it will be destroyed also.
Insert Image >> /FrontEnd/Notes/Notes_Pic/JS_EC_3.png

Call Stack
To keep the track of all the contexts, including global and functional, the JavaScript engine uses a call stack. A call stack is also known as an 'Execution Context Stack', 'Runtime Stack', or 'Machine Stack'.

It uses the LIFO principle (Last-In-First-Out). When the engine first starts executing the script, it creates a global context and pushes it on the stack. Whenever a function is invoked, similarly, the JS engine creates a function stack context for the function and pushes it to the top of the call stack and starts executing it.

When execution of the current function is complete, then the JavaScript engine will automatically remove the context from the call stack and it goes back to its parent.

Let's see the following example:

function funcA(m,n) {
    return m * n;
}

function funcB(m,n) {
    return funcA(m,n);
}

function getResult(num1, num2) {
    return funcB(num1, num2)
}

var res = getResult(5,6);

console.log(res); // 30

In this example, the JS engine creates a global execution context that enters the Memory creation phase.

First it allocates memory for funcA, funcB, the getResult function, and the res variable. Then it invokes getResult(), which will be pushed on the call stack.

Then getResult() will call funcB(). At this point, funcB's context will be stored on the top of the stack. Then it will start executing and call another function funcA(). Similarly, funcA's context will be pushed.

Once execution of each function is done, it will be removed from the call stack. The following picture depicts the entire process of the execution:
Insert Image >> /FrontEnd/Notes/Notes_Pic/JS_EC_4.png

The call stack has its own fixed size depending on the system or browser. If the number of contexts exceeds the limit, then a stack overflow error will occur. This happens with a recursive function that has no base condition.

function display() {
    display();
}

display();

C:\Users\rwiteshbera\Desktop\Javascript\n.js:2
    display();
    ^
RangeError: Maximum call stack size exceeded

👉🏻 Hoisting
ref : https://www.youtube.com/watch?v=Fnlnw8uY6jo&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=4
Hoisting in JavaScript refers to the mechanism where the JavaScript interpreter appears to move the declarations of variables, functions, and classes to the top of their respective scopes before the code is executed. This means that you can use a variable or call a function before it is explicitly declared in your code, without encountering a "not defined" error.

Key aspects of Hoisting:
Declarations are hoisted, initializations are not:
Only the declaration part of a variable or function is moved to the top of the scope, not its assignment or definition.

1. var variables:
When var is used, the variable declaration is hoisted to the top of its function or global scope, and it is initialized with undefined.
console.log(myVar); // Output: undefined
var myVar = 10;
console.log(myVar); // Output: 10

2. let and const variables: Declarations with let and const are also hoisted, but they are not initialized with undefined. Instead, they enter a "Temporal Dead Zone" (TDZ) until their declaration line is reached.
This means that while the variable name is technically hoisted, it cannot be accessed or used before its initialization line is reached in the code. Attempting to do so will result in a ReferenceError.
 
// console.log(myLet); // Throws ReferenceError: Cannot access 'myLet' before initialization
let myLet = 20;  // initialization line
console.log(myLet); // Output: 20

3. Function declarations: Function declarations are fully hoisted, meaning both the function's name and its definition are moved to the top of their scope. This allows you to call a function before its declaration in the code.
myFunction(); // Output: Hello from myFunction!
function myFunction() {
   console.log("Hello from myFunction!");
}

4. Function expressions: Function expressions (e.g., const myFunc = function() {}) are treated like variable declarations. Their variable name is hoisted, but the function's definition is not.
// myFuncExpression(); // Throws TypeError: myFuncExpression is not a function
const myFuncExpression = function() {
   console.log("Hello from myFuncExpression!");
};
myFuncExpression(); // Output: Hello from myFuncExpression!

5. Arrow functions: If an arrow function is declared using var, the variable declaration is hoisted, but its initial value is undefined. Therefore, attempting to call the arrow function before its actual assignment will lead to a TypeError because you are trying to invoke undefined as a function. 
Declared with let or const, arrow functions are subject to the Temporal Dead Zone (TDZ).
fun();  // TypeError: fun is not a function

var fun = () => {
  console.log("hello");
}

fun();  // ReferenceError: Cannot access 'fun' before initialization

const fun = () => {
  console.log("hello");
}

Understanding hoisting is crucial for avoiding unexpected behavior in your JavaScript code, especially when working with var and accessing variables before their explicit declaration. Using let and const for variable declarations is generally recommended as it helps in preventing common hoisting-related issues due to the Temporal Dead Zone.

Hoisting in JavaScript is a direct consequence of the memory creation phase of the execution context:

During the Memory creation phase of an execution context, the JavaScript engine performs the following actions before any code is actually executed:
a) Memory Allocation for Variables and Functions:
	1. For var declarations, memory is allocated, and the variable is initialized with undefined.
	2. For let and const declarations, memory is allocated, but the variables remain uninitialized (they are in a "temporal dead zone") until their declaration line is reached during the execution phase.
	3. For function declarations, the entire function body is placed into memory.
b) Scope Setup: The engine determines the scope chain for the current execution context.

This pre-processing step, where declarations are "moved" into memory before execution, is what allows you to access var variables (as undefined) and function declarations even before their physical appearance in the code. While let and const declarations are also "hoisted" in the sense that memory is allocated during the Memory creation phase, their uninitialized state in the temporal dead zone prevents early access and results in a ReferenceError if attempted.

getName();
console.log("x1:", x);

var x = 7;

function getName(){
  console.log("hello");
  console.log("x2:", x);
}

In most programming languages, this will result out to be an error because you cannot access variables before you have initialized it, but in javascript if we try to run this code, we will get this output :
hello
x2: undefined
x1: undefined
This happened because in the Memory creation phase of the execution context, js will allocate memory to all the variables and function present in the program, stores the variables (defined with var) with values as undefined and function references. So when we try to run the getName() function even though it has been defined after the call, the function is invoked perfectly.

Accessing variables before/without defining :

1. scenario 1:
var =>
console.log(x); // undefined
var x = 10; 
console.log(x); // 10
The variable is stored in the memory as undefined

2. scenario 2:
let/const =>
console.log(x); // ReferenceError: Cannot access 'x' before initialization [because it is in TDZ]
let x = 10;
The varialbe is marked as 'uninitialized binding' because it is in TDZ. Js knows about the variable but is not initialized yet because it it defined with let/const.

3. scenario 3:
console.log(x); // ReferenceError: x is not defined
Js doesn't even know about the variable because there wasn't any space reserved in the memory space for the variable x because it never entered in the memory creation phase(because of never defining the variable) and directly ran in the execution phase., so js couldn't get the track of the variable.

visual representation in browser's debugger of
1. hoisting & execution context : https://www.youtube.com/watch?v=Fnlnw8uY6jo&t=05m20s
2. nested call stack : https://www.youtube.com/watch?v=Fnlnw8uY6jo&t=15m03s

👉🏻 Temporal Dead Zone (TDZ)
The Temporal Dead Zone is the time between when a variable is hoisted into memory (during the Memory creation phase) and when it is actually initialized (during the execution phase).
It refers to the period of time between the beginning of a scope and the actual declaration/initialization of a variable declared with let or const. During this period, the variable exists within the scope but is in an "uninitialized" state, making any attempt to access it result in a ReferenceError. 

In this window of time, the variable exists in memory, but cannot be accessed — if you try, you’ll get a ReferenceError.
Key characteristics of the TDZ:
Applies to let and const:
Unlike var declarations, which are hoisted to the top of the global scope and initialized with undefined by default, let and const declarations are also hoisted to the top of the global scope but remain uninitialized in the TDZ. In other words, javascript knows about let and const variables but does not initialized them.
Scope-based:
The TDZ begins when the code execution enters the block or scope where the let or const variable is declared.
Ends at declaration:
The TDZ for a specific variable ends when the JavaScript engine reaches the line of code where that variable is declared and, if applicable, initialized with a value.
Prevents early access:
The primary purpose of the TDZ is to prevent developers from using variables declared with let or const before they are explicitly declared and potentially assigned a value, thus promoting more predictable and less error-prone code.

let/const =>
// TDZ starts here for 'y'
console.log(y); // ReferenceError: Cannot access 'y' before initialization [because it is in TDZ]
let y = "Hello"; 
// TDZ ends here for 'y'

var =>
console.log(x); // undefined
var y = 10; 
console.log(x); // 10

TDZ is not a separate physical location in memory. Instead, it’s a state of a variable binding inside the scope’s environment record (the internal data structure JavaScript uses to manage variables). TDZ is more of a rule / state in the language spec than a literal "box in memory."

Flow -
When a variable is hoisted, an entry for it is created in the environment record.
For var, that entry is initialized with undefined.
For let/const/class, that entry is marked as uninitialized.
Accessing an uninitialized binding → ReferenceError.
Once execution reaches the declaration line, the binding is initialized with the given value, and TDZ ends.

// At this point, x exists in memory but is uninitialized
// (engine marks x as "TDZ" in the Memory creation phase, TDZ -> {x})
let x = 10; // x is now initialized so it as unmarked from TDZ, (TDZ - {})

If a varialbe is accessed while it is marked as TDZ, it will throw ReferencenError 

Think of TDZ as a "Do Not Touch" sign on a variable:
The variable is already listed in the scope (so the engine knows about it).
But until the declaration line runs, trying to touch it will throw an error.
Once initialized, the sign is removed.

How JavaScript Handles Variables (ECMAScript Spec Level)
When code runs, JS creates an Execution Context with an Environment Record (basically a hidden object that stores variables and functions for that scope).
There are two main record types:
1. Declarative Environment Record → used for let, const, class, and parameters.
2. Object Environment Record → used for var (and global scope tied to window/globalThis).

ref : https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#sec-declarative-environment-records

How phases are worked with TDZ ?

Example :
console.log(a); // ❌ ReferenceError
let a = 5;

Flow of above program :
1. Memory Creation Phase (Hoisting Step)
The scope’s environment record is created.
For let a:
	The record has an entry for a.
	That entry is marked as "uninitialized" (spec literally says: "uninitialized binding")
This “uninitialized” state is what we call the Temporal Dead Zone (TDZ).

So in memory (conceptually):
Environment Record:
  a → <uninitialized>

2. Execution Phase

1. console.log(a)
Engine looks up a.
Sees it exists but is uninitialized.
Throws ReferenceError.

2. Line let a = 5
Engine assigns 5 to a.
Now the record becomes:
a → 5

3. From here, a is usable.

In the ECMAScript spec, you’ll see steps like:
> CreateMutableBinding → reserve a slot for the variable in the environment record (hoisting step).
> SetMutableBinding → assign a value to it (execution step).
> If you try to access before initialization → spec says: "If the binding is uninitialized, throw a ReferenceError" → this is the TDZ rule.


👉🏻 Non-Writable property in object
In JavaScript, a "non-writable" property refers to an object property whose writable attribute in its property descriptor is set to false. This means that the value of that property cannot be reassigned or changed through a direct assignment operation.
Here's a breakdown:

Property Descriptors:
Every property in a JavaScript object has a set of attributes defined in its "property descriptor." These attributes include value, writable, enumerable, and configurable.

writable: false:
When the writable attribute is set to false, any attempt to change the property's value using the assignment operator (=) will not succeed.

Strict Mode Behavior:
In strict mode, attempting to write to a non-writable property will result in a TypeError.
In non-strict mode, the assignment will be silently ignored, and the property's value will remain unchanged.

Creating Non-Writable Properties:
Object.defineProperty(): You can explicitly define a property as non-writable when creating it or modifying an existing property using Object.defineProperty().
Object.freeze(): This method makes an entire object immutable, meaning all its existing properties become non-writable, non-configurable, and their values cannot be changed.

const myObject = {};

// Define 'a' as a non-writable property
Object.defineProperty(myObject, 'a', {
  value: 10,
  writable: false // This makes 'a' non-writable
});

console.log(myObject.a); // Output: 10

// Attempt to change 'a'
myObject.a = 20; // In strict mode, this would throw a TypeError; in non-strict mode, it's ignored.

console.log(myObject.a); // Output: 10 (value remains unchanged)

Object.freeze():
const myImmutableObject = { key1: "value1" };
Object.freeze(myImmutableObject);

// myImmutableObject.key1 = "newValue"; // This will not work (and throws an error in strict mode)
// myImmutableObject.newKey = "anotherValue"; // This will not work (and throws an error in strict mode)

👉🏻 Strict Mode
Strict mode in JavaScript is a feature introduced in ECMAScript 5 (ES5) that allows developers to opt into a restricted variant of the language. It enforces stricter parsing and error handling, making the code more robust and secure by eliminating some "silent errors" and preventing "unsafe" actions.

How to enable strict mode:
You can enable strict mode by adding the string literal "use strict"; (or 'use strict';) at the beginning of a JavaScript file or at the beginning of a function body. 

// Strict mode for the entire script
"use strict";
// All code in this file will run in strict mode

function myFunction() {
  // Strict mode for this function only
  "use strict";
  // Code within this function will run in strict mode
}
// Code outside this function runs in normal (sloppy) mode

Key characteristics and effects of strict mode:
Eliminates silent errors:
It converts certain errors that would silently fail in "sloppy mode" (non-strict mode) into thrown errors. For example, assigning a value to an undeclared variable, which would create a global variable in sloppy mode, throws an error in strict mode.
Fixes mistakes hindering optimizations:
It addresses issues that make it difficult for JavaScript engines to perform optimizations, potentially leading to faster code execution.
Prohibits certain syntax:
It disallows certain syntax that is likely to be defined in future versions of ECMAScript or is considered problematic. Examples include using with statements and octal literals.
Enhances security:
It prevents certain "unsafe" actions, such as referencing the global window or document objects with this inside a function (it returns undefined instead).
Enforces stricter rules:
It introduces rules like disallowing duplicate parameter names in functions and preventing deletion of undeletable properties.

Examples of Strict Mode Enforcement:
this in Non-Method Functions: In strict mode, this is undefined in functions called without an explicit object context (e.g., simple function calls), preventing accidental global variable creation.
"use strict";
function logThis() {
  // Logs undefined
  console.log(this);
}
logThis();
Undeclared Variables: Strict mode throws a ReferenceError if you try to assign a value to an undeclared variable.
"use strict";
// This will cause a ReferenceError
undeclaredVar = "hello";
In JavaScript, a variable defined without let, const, or var in non-strict mode outside of any function automatically becomes a global variable. This means it is added as a property to the global object.(e.g., window in a browser environment or global in Node.js).
window.undeclaredVar // in browser environment
global.undeclaredVar // in Node.js
Deleting Variables, Functions, or Arguments: Deleting plain names (variables, functions, or arguments) is forbidden and results in a SyntaxError in strict mode.
"use strict";
let myVar = 5;
// This will cause a SyntaxError
delete myVar;
Duplicate Parameter Names: Functions with duplicate parameter names are not allowed and will throw a SyntaxError.
"use strict";
// This will cause a SyntaxError
function sum(a, a) {
  return a + a;
}
Octal Literals: Using a leading zero for octal numbers (e.g., 010) is a SyntaxError in strict mode. Use the 0o prefix for octal literals (e.g., 0o10).
"use strict";
// This will cause a SyntaxError
let octalNum = 010;
with Statement: The with statement is completely forbidden and results in a SyntaxError.
"use strict";
// This will cause a SyntaxError
with (obj) {
  // ...
}
Writing to Read-Only or Get-Only Properties: Attempting to assign a value to a non-writable or get-only property will throw a TypeError.
"use strict";
const obj = {};
Object.defineProperty(obj, 'prop', { value: 42, writable: false });
// This will cause a TypeError
obj.prop = 10;

Advanced Javascript Crash Course => https://www.youtube.com/watch?v=R9I85RhI7Cg (Below Notes are created from this video, most of the topic are left like prototype/inheritance/class/iterables & iterators/generators because they are not necessary etc)

👉🏻 Scope
1. Block scope - variables declared inside a pair of curly braces cannot be accessed from outside
the block
2. Function scope - variables declared inside a function cannot not be accessed from outside the
function
3. Global scope - globally scoped variables can be accessed inside a block or function

eg. Block Scope :
{
  const x = 123;
  console.log(x); // 123
}
console.log(x) // Error : 'x' is not defined


👉🏻 Closure
In JavaScript, when we return a function from another function, we are effectively returning a combination of the function definition along with the function's scope. This would let the function definition have an associated persistent memory which could hold on to live data between executions. That combination of the function and its scope chain is what is called a closure in JavaScript.

scenario 1 :
const outer = ()=>{
    let counter = 0;
    const inner =()=>{
        counter++;
        console.log(counter);
    }
    inner();
}

outer();// counter set to 0
outer();// counter set to 0 again and increased by 1 by inner() function, because it was only called one time in the outer function.

Output : 
1
1

scenario 2 (Closure) :
// Define a function `outer` which declares a local variable `counter`
const outer = () => {
    let counter = 0; // `counter` is scoped to the `outer` function

    // Define an inner function that increments and logs `counter`
    const inner = () => {
        counter++;               // Increase the value of counter
        console.log(counter);    // Print the updated value
    }

    // Return the `inner` function from `outer`
    return inner; // This forms a closure: `inner` "remembers" `counter`
}

// Call `outer` and store its return value (which is the `inner` function) in `fun1`
const fun1 = outer(); // Here, `counter` is initialized to 0 and `fun1` holds reference to `inner`

fun1(); // Logs: 1
// - `counter` is incremented from 0 to 1
// - Because `inner` still "remembers" its outer `counter`, the state persists

fun1(); // Logs: 2
// - `counter` is now incremented again (1 → 2)
// - The same closure is being used, so the same `counter` variable is being updated

// Note:
// Even though `outer` has finished execution, `counter` isn't garbage collected
// because the returned `inner` function (stored in `fun1`) still has access to it.
// This behavior is called a "closure" — where a function remembers its lexical scope.

// both fun1 are still running inside the outer function and counter never convereted to 0 again, which caused the counter to increased two times

Output : 
1
2


👉🏻 Function Currying
Currying is a process in functional programming in which we transform a function with multiple arguments into a sequence of nesting functions that take one argument at a time.
Currying in JavaScript transforms a function with multiple arguments into a sequence of functions, each taking a single argument. This technique offers several benefits:
1. Code Reusability: Curried functions can be reused in various contexts. By partially applying arguments, new functions can be derived from existing ones, reducing code duplication.
2. Improved Readability: Breaking down complex logic into smaller, manageable pieces makes the code easier to understand and maintain.
3. Enhanced Flexibility: Currying enables more flexible function composition. Functions can be combined and reused in different ways, adapting to changing requirements. 
4. Partial Application: Currying facilitates partial application, allowing you to create specialized functions by fixing some arguments of a more general function.
5. Functional Programming: Currying promotes functional programming practices, leading to more robust and maintainable code.
6. Simplified Function Calls: By pre-filling some arguments, function calls can be simplified, making code more concise.
7. Avoid Repetition: Currying helps avoid repeating the same arguments multiple times, making code more streamlined.
8. Higher-Order Functions: Currying enables the creation of higher-order functions, enhancing the flexibility and power of your code.
function f(a,b,c) is transformed to f(a)(b)(c)

1. Without Currying
function logMessage(prefix, message) {
  console.log(`[${prefix}] ${message}`);
}

// Usage
logMessage("INFO", "Server started");
logMessage("ERROR", "Something went wrong");
You have to repeat "INFO" or "ERROR" every time you call it — no reusability.

2. With Currying
function curriedLog(prefix) {
  return function(message) {
    console.log(`[${prefix}] ${message}`);
  }
}

// Usage
const infoLogger = curriedLog("INFO");
const errorLogger = curriedLog("ERROR");

infoLogger("Server started");        // [INFO] Server started
errorLogger("Something went wrong"); // [ERROR] Something went wrong


